package com.xelitexirish.malwareshield.service;

import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.util.Log;
import android.widget.Toast;

import com.xelitexirish.malwareshield.MainActivity;
import com.xelitexirish.malwareshield.db.DatabaseContract;
import com.xelitexirish.malwareshield.exception.Exceptions;
import com.xelitexirish.malwareshield.preference.Prefs;
import com.xelitexirish.malwareshield.util.Constants;
import com.xelitexirish.malwareshield.util.EnumStatusCodes;
import com.xelitexirish.malwareshield.util.HostsFileParser;
import com.xelitexirish.malwareshield.util.HostsHelper;
import com.xelitexirish.malwareshield.db.ProviderHelper;

import org.sufficientlysecure.rootcommands.Shell;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLConnection;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

public class ApplyHostsFileService extends WakeService {

    private Context context;

    private int mNumberOfFailedDownloads;
    private int mNumberOfDownloads;

    public ApplyHostsFileService() {
        super(ApplyHostsFileService.class.getSimpleName());
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        context = this;

        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    protected void doWakefulWork(Intent intent) {

        int downloadResult = download();
        if(downloadResult == EnumStatusCodes.SUCCESS) {
            int applyResult = applyHostsFile();
        }else {
            Toast.makeText(context, "Download failed, please check your internet connection", Toast.LENGTH_SHORT).show();
        }
    }

    /**
     * Downloads files from hosts sources
     *
     * @return return code
     */
    private int download() {
        Cursor enabledHostsSourcesCursor;

        byte data[];
        int count;
        long currentLastModifiedOnline;

        int returnCode = EnumStatusCodes.SUCCESS; // default return code

        if (MainActivity.hasInternetConnection(context)) {


            // output to write into
            FileOutputStream fileOutputStream = null;

            try {
                fileOutputStream = context.openFileOutput(Constants.DOWNLOADED_HOSTS_FILENAME, Context.MODE_PRIVATE);

                mNumberOfFailedDownloads = 0;
                mNumberOfDownloads = 0;

                // get cursor over all enabled hosts source
                enabledHostsSourcesCursor = ProviderHelper.getEnabledHostsSourcesCursor(context);

                // iterate over all hosts sources in db with cursor
                if (enabledHostsSourcesCursor.moveToFirst()) {
                    do {
                        mNumberOfDownloads++;

                        InputStream inputStream = null;
                        BufferedInputStream bufferedInputStream = null;
                        String currentUrl = enabledHostsSourcesCursor.getString(enabledHostsSourcesCursor.getColumnIndex("url"));

                        try {
                            Log.v(Constants.TAG, "Downloading hosts file: " + currentUrl);

                            /* build connection */
                            URL mURL = new URL(currentUrl);
                            URLConnection connection = mURL.openConnection();
                            connection.setConnectTimeout(15000);
                            connection.setReadTimeout(30000);

                            /* connect */
                            connection.connect();
                            inputStream = connection.getInputStream();

                            bufferedInputStream = new BufferedInputStream(inputStream);
                            if (inputStream == null) {
                                Log.e(Constants.TAG, "Stream is null");
                            }

                            /* download with progress */
                            data = new byte[1024];
                            count = 0;

                            // run while only when thread is not cancelled
                            while ((count = bufferedInputStream.read(data)) != -1) {
                                fileOutputStream.write(data, 0, count);
                            }

                            // add line seperator to add files together in one file
                            fileOutputStream.write(Constants.LINE_SEPERATOR.getBytes());

                            // save last modified online for later use
                            currentLastModifiedOnline = connection.getLastModified();

                            ProviderHelper.updateHostsSourceLastModifiedOnline(context, enabledHostsSourcesCursor.getInt(enabledHostsSourcesCursor.getColumnIndex(DatabaseContract.HostsSources._ID)), currentLastModifiedOnline);

                        } catch (IOException e) {
                            Log.e(Constants.TAG, "Exception while downloading from " + currentUrl, e);
                            mNumberOfFailedDownloads++;

                            // set last_modified_online of failed download to 0 (not available)
                            ProviderHelper.updateHostsSourceLastModifiedOnline(context, enabledHostsSourcesCursor.getInt(enabledHostsSourcesCursor.getColumnIndex(DatabaseContract.HostsSources._ID)), 0);

                        } finally {
                            // flush and close streams
                            try {
                                if (fileOutputStream != null) {
                                    fileOutputStream.flush();
                                }
                                if (bufferedInputStream != null) {
                                    bufferedInputStream.close();
                                }
                                if (inputStream != null) {
                                    inputStream.close();
                                }
                            } catch (Exception e) {
                                Log.e(Constants.TAG, "Exception on flush and closing streams.", e);
                            }
                        }

                    } while (enabledHostsSourcesCursor.moveToNext());
                }

                // close cursor in the end
                if (enabledHostsSourcesCursor != null && !enabledHostsSourcesCursor.isClosed()) {
                    enabledHostsSourcesCursor.close();
                }

                // if all downloads failed return download_fail error
                if (mNumberOfDownloads == mNumberOfFailedDownloads && mNumberOfDownloads != 0) {
                    returnCode = EnumStatusCodes.DOWNLOAD_FAIL;
                }
            } catch (Exception e) {
                Log.e(Constants.TAG, "Private File can not be created, Exception: " + e);
                returnCode = EnumStatusCodes.PRIVATE_FILE_FAIL;
            } finally {
                try {
                    if (fileOutputStream != null) {
                        fileOutputStream.close();
                    }
                } catch (Exception e) {
                    Log.e(Constants.TAG, "Exception on close of out.", e);
                }
            }
        } else {
            returnCode = EnumStatusCodes.NO_CONNECTION;
        }

        return returnCode;
    }

    /**
     * Apply hosts file
     *
     * @return return code
     */
    int applyHostsFile() {

        int returnCode = EnumStatusCodes.SUCCESS; // default return code
        BufferedOutputStream bufferedOutputStream = null;

        try {
            /* PARSE: parse hosts files to sets of hostnames and comments */

            FileInputStream fileInputStream = context.openFileInput(Constants.DOWNLOADED_HOSTS_FILENAME);

            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(fileInputStream));

            // Use whitelist and/or redirection rules from hosts sources only if enabled in preferences
            HostsFileParser parser = new HostsFileParser(bufferedReader);

            fileInputStream.close();

            /**
             *READ DATABSE CONTENT
             */

            // add blacklist from db
            parser.addBlacklist(ProviderHelper.getEnabledBlacklistHashSet(context));

            // get hosts sources list from db
            ArrayList<String> enabledHostsSources = ProviderHelper.getEnabledHostsSourcesArrayList(context);
            Log.d(Constants.TAG, "Enabled hosts sources list: " + enabledHostsSources.toString());

            FileOutputStream fileOutputStream = context.openFileOutput(Constants.HOSTS_FILENAME, Context.MODE_PRIVATE);

            bufferedOutputStream = new BufferedOutputStream(fileOutputStream);

            // build current timestamp for header
            SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            Date currentDate = new Date();

            // add adaway header
            String header = Constants.HEADER1 + Constants.LINE_SEPERATOR + "# " +
                    formatter.format(currentDate) + Constants.LINE_SEPERATOR + Constants.HEADER2 +
                    Constants.LINE_SEPERATOR + Constants.HEADER_SOURCES;
            bufferedOutputStream.write(header.getBytes());

            // write sources into header
            String source = null;
            for (String host : enabledHostsSources) {
                source = Constants.LINE_SEPERATOR + "# " + host;
                bufferedOutputStream.write(source.getBytes());
            }

            bufferedOutputStream.write(Constants.LINE_SEPERATOR.getBytes());

            String redirectionIP = Constants.REDIRECTION_HOSTNAME;

            // add "127.0.0.1 localhost" entry
            String localhost = Constants.LINE_SEPERATOR + Constants.LOCALHOST_IPv4 + " "
                    + Constants.LOCALHOST_HOSTNAME + Constants.LINE_SEPERATOR;
            bufferedOutputStream.write(localhost.getBytes());

            bufferedOutputStream.write(Constants.LINE_SEPERATOR.getBytes());

            // write hostnames
            String line;
            for (String hostname : parser.getBlacklist()) {
                line = Constants.LINE_SEPERATOR + redirectionIP + " " + hostname;
                bufferedOutputStream.write(line.getBytes());
            }

            // hosts file has to end with new line, when not done last entry won't be recognized
            bufferedOutputStream.write(Constants.LINE_SEPERATOR.getBytes());

        } catch (FileNotFoundException e) {
            Log.e(Constants.TAG, "file to read or file to write could not be found", e);

            returnCode = EnumStatusCodes.PRIVATE_FILE_FAIL;
        } catch (IOException e) {
            Log.e(Constants.TAG, "files can not be written or read", e);
            returnCode = EnumStatusCodes.PRIVATE_FILE_FAIL;

        } finally {
            try {
                if (bufferedOutputStream != null) {
                    bufferedOutputStream.flush();
                    bufferedOutputStream.close();
                }
            } catch (Exception e) {
                Log.e(Constants.TAG, "Error closing output streams", e);
            }
        }

        // delete downloaded hosts file from private storage
        context.deleteFile(Constants.DOWNLOADED_HOSTS_FILENAME);

        /* APPLY: applyHostsFile hosts file using RootTools in copyHostsFile() */

        Shell rootShell = null;
        try {
            rootShell = Shell.startRootShell();
        } catch (Exception e) {
            Log.e(Constants.TAG, "Problem opening a root shell!", e);
        }

        // copy build hosts file with RootTools, based on target from preferences
        try {
            if (Prefs.getApplyMethod(context).equals("writeToSystem")) {

                HostsHelper.copyHostsFile(context, Constants.ANDROID_SYSTEM_ETC_HOSTS, rootShell);
            } else if (Prefs.getApplyMethod(context).equals("writeToDataData")) {

                HostsHelper.copyHostsFile(context, Constants.ANDROID_DATA_DATA_HOSTS, rootShell);
            } else if (Prefs.getApplyMethod(context).equals("writeToData")) {

                HostsHelper.copyHostsFile(context, Constants.ANDROID_DATA_HOSTS, rootShell);
            } else if (Prefs.getApplyMethod(context).equals("customTarget")) {

                HostsHelper.copyHostsFile(context, Prefs.getCustomTarget(context), rootShell);
            }
        } catch (Exceptions.NotEnoughSpaceException e) {
            Log.e(Constants.TAG, "Exception: ", e);

            returnCode = EnumStatusCodes.NOT_ENOUGH_SPACE;
        } catch (Exceptions.RemountException e) {
            Log.e(Constants.TAG, "Exception: ", e);

            returnCode = EnumStatusCodes.REMOUNT_FAIL;
        } catch (Exceptions.CommandException e) {
            Log.e(Constants.TAG, "Exception: ", e);

            returnCode = EnumStatusCodes.COPY_FAIL;
        }

        // delete generated hosts file from private storage
        context.deleteFile(Constants.HOSTS_FILENAME);

        /* check if hosts file is applied with chosen method */
        // check only if everything before was successful
        if (returnCode == EnumStatusCodes.SUCCESS) {
            if (Prefs.getApplyMethod(context).equals("writeToSystem")) {

                /* /system/etc/hosts */

                if (!HostsHelper.isHostsFileCorrect(Constants.ANDROID_SYSTEM_ETC_HOSTS)) {
                    returnCode = EnumStatusCodes.APPLY_FAIL;
                }
            } else if (Prefs.getApplyMethod(context).equals("writeToDataData")) {

                /* /data/data/hosts */

                if (!HostsHelper.isHostsFileCorrect(Constants.ANDROID_DATA_DATA_HOSTS)) {
                    returnCode = EnumStatusCodes.APPLY_FAIL;
                } else {
                    if (!HostsHelper.isSymlinkCorrect(Constants.ANDROID_DATA_DATA_HOSTS, rootShell)) {
                        returnCode = EnumStatusCodes.SYMLINK_MISSING;
                    }
                }
            } else if (Prefs.getApplyMethod(context).equals("writeToData")) {

                /* /data/data/hosts */

                if (!HostsHelper.isHostsFileCorrect(Constants.ANDROID_DATA_HOSTS)) {
                    returnCode = EnumStatusCodes.APPLY_FAIL;
                } else {
                    if (!HostsHelper.isSymlinkCorrect(Constants.ANDROID_DATA_HOSTS, rootShell)) {
                        returnCode = EnumStatusCodes.SYMLINK_MISSING;
                    }
                }
            } else if (Prefs.getApplyMethod(context).equals("customTarget")) {

                /* custom target */

                String customTarget = Prefs.getCustomTarget(context);

                if (!HostsHelper.isHostsFileCorrect(customTarget)) {
                    returnCode = EnumStatusCodes.APPLY_FAIL;
                } else {
                    if (!HostsHelper.isSymlinkCorrect(customTarget, rootShell)) {
                        returnCode = EnumStatusCodes.SYMLINK_MISSING;
                    }
                }
            }
        }

        try {
            rootShell.close();
        } catch (Exception e) {
            Log.e(Constants.TAG, "Problem closing the root shell!", e);
        }

        return returnCode;
    }
}
