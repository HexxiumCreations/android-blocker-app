package com.xelitexirish.malwareshield.db;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.content.Context;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.sqlite.SQLiteConstraintException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteQueryBuilder;
import android.net.Uri;
import android.provider.BaseColumns;
import android.support.annotation.Nullable;
import android.text.TextUtils;
import android.util.Log;

import com.xelitexirish.malwareshield.util.Constants;

import java.util.Arrays;

public class DatabaseProvider extends ContentProvider{

    private static final UriMatcher sUriMatcher = buildUriMatcher();

    private static final int HOSTS_SOURCES = 1000;
    private static final int HOSTS_SOURCES_ID = 1001;

    private static final int BLACKLIST = 2000;
    private static final int BLACKLIST_ID = 2001;


    private DatabaseHandler databaseHandler;

    /**
     * Build and return a {@link UriMatcher} that catches all {@link Uri} variations supported by
     * this {@link ContentProvider}.
     */
    private static UriMatcher buildUriMatcher() {
        final UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);
        final String authority = DatabaseContract.CONTENT_AUTHORITY;

        // Hosts sources
        matcher.addURI(authority, DatabaseContract.PATH_HOSTS_SOURCES, HOSTS_SOURCES);
        matcher.addURI(authority, DatabaseContract.PATH_HOSTS_SOURCES + "/#", HOSTS_SOURCES_ID);

        // Blacklist
        matcher.addURI(authority, DatabaseContract.PATH_BLACKLIST, BLACKLIST);
        matcher.addURI(authority, DatabaseContract.PATH_BLACKLIST + "/#", BLACKLIST_ID);

        return matcher;
    }

    @Override
    public boolean onCreate() {
        final Context context = getContext();
        databaseHandler = new DatabaseHandler(context);
        return true;
    }

    @Nullable
    @Override
    public String getType(Uri uri) {
        final int match = sUriMatcher.match(uri);
        switch (match){
            case HOSTS_SOURCES:
                return DatabaseContract.HostsSources.CONTENT_TYPE;
            case HOSTS_SOURCES_ID:
                return DatabaseContract.HostsSources.CONTENT_ITEM_TYPE;
            case BLACKLIST:
                return DatabaseContract.Blacklist.CONTENT_TYPE;
            case BLACKLIST_ID:
                return DatabaseContract.Blacklist.CONTENT_ITEM_TYPE;
            default:
                throw new UnsupportedOperationException("Unknown uri: " + uri);
        }
    }

    @Nullable
    @Override
    public Uri insert(Uri uri, ContentValues values) {
        Log.d(Constants.TAG, "insert(uri=" + uri + ", values=" + values.toString() + ")");

        final SQLiteDatabase db = databaseHandler.getWritableDatabase();

        Uri rowUri = null;
        long rowId = -1;
        try {
            final int match = sUriMatcher.match(uri);
            switch (match) {
                case HOSTS_SOURCES:
                    rowId = db.insertOrThrow(DatabaseHandler.Tables.HOSTS_SOURCES, null, values);
                    rowUri = DatabaseContract.HostsSources.buildUri(Long.toString(rowId));
                    break;

                case BLACKLIST:
                    rowId = db.insertOrThrow(DatabaseHandler.Tables.BLACKLIST, null, values);
                    rowUri = DatabaseContract.Blacklist.buildUri(Long.toString(rowId));
                    break;

                default:
                    throw new UnsupportedOperationException("Unknown uri: " + uri);
            }
        } catch (SQLiteConstraintException e) {
            Log.e(Constants.TAG, "Constraint exception on insert! Entry already existing?");
        }

        // notify of changes in db
        getContext().getContentResolver().notifyChange(uri, null);

        return rowUri;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {

        SQLiteQueryBuilder sqLiteQueryBuilder = new SQLiteQueryBuilder();
        SQLiteDatabase database = databaseHandler.getReadableDatabase();

        final int match = sUriMatcher.match(uri);
        switch (match) {
            case HOSTS_SOURCES:
                sqLiteQueryBuilder.setTables(DatabaseHandler.Tables.HOSTS_SOURCES);
                break;

            case BLACKLIST:
                sqLiteQueryBuilder.setTables(DatabaseHandler.Tables.BLACKLIST);
                break;

            default:
                throw new UnsupportedOperationException("Unknown uri: " + uri);
        }

        Cursor cursor = sqLiteQueryBuilder.query(database, projection, selection, selectionArgs, null, null, sortOrder);
        // notify through cursor
        cursor.setNotificationUri(getContext().getContentResolver(), uri);
        return cursor;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {

        final SQLiteDatabase database = databaseHandler.getWritableDatabase();

        int count = 0;
        try {
            final int match = sUriMatcher.match(uri);
            switch (match) {
                case HOSTS_SOURCES_ID:
                    count = database.update(DatabaseHandler.Tables.HOSTS_SOURCES, values, buildDefaultSelection(uri, selection), selectionArgs);
                    break;

                case BLACKLIST_ID:
                    count = database.update(DatabaseHandler.Tables.BLACKLIST, values, buildDefaultSelection(uri, selection), selectionArgs);
                    break;

                default:
                    throw new UnsupportedOperationException("Unknown uri: " + uri);
            }
        } catch (SQLiteConstraintException e) {
            Log.e(Constants.TAG, "Constraint exception on update! Entry already existing?");
        }
        // notify of changes in db
        getContext().getContentResolver().notifyChange(uri, null);

        return count;
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        Log.v(Constants.TAG, "delete(uri=" + uri + ")");

        final SQLiteDatabase database = databaseHandler.getWritableDatabase();

        int count;
        final int match = sUriMatcher.match(uri);
        switch (match) {
            case HOSTS_SOURCES_ID:
                count = database.delete(DatabaseHandler.Tables.HOSTS_SOURCES, buildDefaultSelection(uri, selection), selectionArgs);
                break;

            case BLACKLIST_ID:
                count = database.delete(DatabaseHandler.Tables.BLACKLIST, buildDefaultSelection(uri, selection), selectionArgs);
                break;

            default:
                throw new UnsupportedOperationException("Unknown uri: " + uri);
        }

        // notify of changes in database
        getContext().getContentResolver().notifyChange(uri, null);

        return count;
    }

    /**
     * Build default selection statement. If no extra selection is specified only build where clause
     * with rowId
     *
     * @param uri
     * @param selection
     * @return
     */
    private String buildDefaultSelection(Uri uri, String selection) {
        String rowId = uri.getPathSegments().get(1);
        String where = "";
        if (!TextUtils.isEmpty(selection)) {
            where = " AND (" + selection + ")";
        }
        return BaseColumns._ID + "=" + rowId + where;
    }
}
