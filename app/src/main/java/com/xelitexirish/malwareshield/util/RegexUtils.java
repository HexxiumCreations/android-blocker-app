package com.xelitexirish.malwareshield.util;


import android.util.Log;
import android.webkit.URLUtil;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexUtils {

    /*
     * Allow hostnames like: localserver example.com example.host.org
     */
    static final private String HOSTNAME_REGEX = "[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-\\_\\.]{0,61}[a-zA-Z0-9]";
    private static Pattern mHostnamePattern;
    private static Matcher mHostnameMatcher;

    /*
     * Allow also hostnames like: localse?ver example*.com exam?le*.host.org
     */
    static final private String WHITELIST_HOSTNAME_REGEX = "[a-zA-Z0-9\\*\\?]|[a-zA-Z0-9\\*\\?][a-zA-Z0-9\\-\\_\\.\\*\\?]{0,61}[a-zA-Z0-9\\*\\?]";
    private static Pattern mWhitelistHostnamePattern;
    private static Matcher mWhitelistHostnameMatcher;

    /*
     * http://stackoverflow.com/questions/46146/what-are-the-java-regular-expressions-for-matching-ipv4
     * -and-ipv6-strings
     */
    static final private String IPV4_REGEX = "(?:25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}";
    private static Pattern mIPv4Pattern;
    private static Matcher mIPv4Matcher;

    /*
     * http://forums.dartware.com/viewtopic.php?t=452
     */
    static final private String IPV6_REGEX = "(((?=(?>.*?::)(?!.*::)))(::)?([0-9A-F]{1,4}::?){0,5}|([0-9A-F]{1,4}:){6})(\2([0-9A-F]{1,4}(::?|$)){0,2}|((25[0-5]|(2[0-4]|1\\d|[1-9])?\\d)(\\.|$)){4}|[0-9A-F]{1,4}:[0-9A-F]{1,4})(?<![^:]:|\\.)";
    private static Pattern mIPv6Pattern;
    private static Matcher mIPv6Matcher;

    /*
     * To find hostname in DNS log
     */
    static final private String TCPDUMP_HOSTNAME_REGEX = "(A\\?|AAAA\\?)\\s(\\S+)\\.\\s";
    private static Pattern mTcpdumpHostnamePattern;
    private static Matcher mTcpdumpHostnameMatcher;

    /*
     * Simplified expression to parse lines in hosts files from hosts sources
     */
    static final private String SIMPLE_IPV6_REGEX = "[0-9A-F\\:\\.]+";

    static final private String HOSTS_PARSER = "^\\s*((?:" + IPV4_REGEX + ")|(?:" + SIMPLE_IPV6_REGEX + "))\\s+(" + HOSTNAME_REGEX + ")\\s*(?:\\#.*)*\\s*$";
    public static Pattern hostsParserPattern;


    static {
        mHostnamePattern = Pattern.compile(HOSTNAME_REGEX);
        mWhitelistHostnamePattern = Pattern.compile(WHITELIST_HOSTNAME_REGEX);
        mIPv4Pattern = Pattern.compile(IPV4_REGEX);
        mIPv6Pattern = Pattern.compile(IPV6_REGEX, Pattern.CASE_INSENSITIVE);
        mTcpdumpHostnamePattern = Pattern.compile(TCPDUMP_HOSTNAME_REGEX);
        hostsParserPattern = Pattern.compile(HOSTS_PARSER, Pattern.CASE_INSENSITIVE);
    }

    /**
     * Just a wrapper
     *
     * @param input
     * @return
     */
    static public boolean isValidUrl(String input) {
        return URLUtil.isValidUrl(input);
    }

    /**
     * I could not find any android class that provides checking of an hostnames, thus I am using
     * regex
     *
     * @param input
     * @return return true if input is valid hostname
     */
    static public boolean isValidHostname(String input) {
        mHostnameMatcher = mHostnamePattern.matcher(input);

        try {
            return mHostnameMatcher.matches();
        } catch (Exception e) {
            Log.e(Constants.TAG, "Error in isValidHostname", e);
            // workaround for some devices that throws jni exceptions: just accept everything
            return true;
        }
    }

    /**
     * Same as above but also allow * and ?
     *
     * @param input
     * @return
     */
    static public boolean isValidWhitelistHostname(String input) {
        mWhitelistHostnameMatcher = mWhitelistHostnamePattern.matcher(input);

        try {
            return mWhitelistHostnameMatcher.matches();
        } catch (Exception e) {
            Log.e(Constants.TAG, "Error in isValidHostname", e);
            // workaround for some devices that throws jni exceptions: just accept everything
            return true;
        }
    }

    /**
     * Check if input is a valid IPv4 address
     */
    static public boolean isValidIPv4(String input) {
        mIPv4Matcher = mIPv4Pattern.matcher(input);

        try {
            return mIPv4Matcher.matches();
        } catch (Exception e) {
            Log.e(Constants.TAG, "Error in isValidIPv4", e);
            // workaround for some devices that throws jni exceptions: just accept everything
            return true;
        }
    }

    /**
     * Check if input is a valid IP address
     */
    static public boolean isValidIP(String input) {
        Log.d(Constants.TAG, "input: " + input);
        Log.d(Constants.TAG, "isvalidipv4: " + isValidIPv4(input));

        return (isValidIPv4(input));
    }
}
